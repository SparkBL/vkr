\section{Оптимизация процесса проведения численных экспериментов}
В рамках разработки программного комплекса для анализа характеристик исследуемой модели системы массового обслуживания с вызываемыми заявками и повторными вызовами особое внимание уделяется процедуре проведения численных экспериментов. Численные результаты являются наиболее репрезентативными в случае, если было проведено достаточное количество экспериментов при наборах параметров, которые описывают функционирование модели в различных ситуациях. Такой подход позволяет удостовериться в верности теоретической стороны исследования посредством анализа объемной выборки данных о работе модели.

\subsection{Имитационная модель}
\subsubsection{Требования к работе}
Для проведения численных экспериментов была разработана имитационная модель. Решение разработать собственное ПО для моделирования было принято ввиду ряда аспектов исследовательской работы, которые требуют создания и анализа большего объема данных. Для этого требуется автоматизировать существенную часть процесса исследования ввиду ограниченного времени и ресурсов. Помимо этого, трудоемкость на последующих этапах работы значительно снижается благодаря структурированности получаемой информации.
Были введены следующие требования к работе имитационной модели:
\begin{itemize}
	\item Программа должна потреблять как можно меньше вычислительных ресурсов, что бы позволило запускать несколько ее экземпляров одновременно.
	\item Способ задания параметров должен позволять выполнять эксперименты повторно.
	\item Имитационная модель должна обладать достаточным быстродействием, чтобы в течение небольшого промежутка времени завершать моделирование системы с параметрами, значительно повышающими трудоемкость вычислений.
	\item Легкая расширяемость. Исходный код программы должен предоставлять возможность добавления новой логики в работу модели.
\end{itemize}
Готовые программные решения не подходят для поставленной задачи, поскольку не выполняют всех перечисленных требований, либо являются платными коммерческими продуктами. По этой причине разработать программное обеспечение для решения узкоспециализированной задачи оказалось эффективнее.

\subsubsection{Объектная модель предметной области}
Принцип работы имитационной модели базируется на обработке событий, происходящих в системе во время ее функционирования. Под событиями понимаются  перемещения заявок по элементам системы. Обработка включает в себя регистрацию времени наступления события в заданном временном интервале.
Программа реализована в рамках объектно--ориентированного подхода. Его преимуществом является возможность построения абстракций над логикой работы конкретных элементов системы, что позволяет удовлетворить требованию легкой расширяемости. 

Объектно--ориентированный подход \cite{fowler1997analysis} к реализации предметной области подразумевает выделение из нее отдельных сущностей, которые могут быть представлены одним самостоятельным объектом, выполняющим конкретную задачу.

В предметной области программы были выделены следующие сущности:
\begin{itemize}
	\item Элемент системы --- объект, являющийся частью модели и выполняющий обработку заявок на протяжении ее работы.
	\item Заявка --- объект, перемещающийся по системе и подлежащий обработке.
	\item Маршрутизатор --- объект, образующий односторонний туннель для перемещения заявок от элемента системы к другому.
	\item Слот --- объект, служащий для соединения двух элементов при помощи маршрутизатора.
\end{itemize}

Процесс моделирования заключается в перемещении заявок от одного элемента к другому. В очередной условный момент времени $T_{cur}$ местонахождение каждой заявки и ее характеристики могут меняться. По этой причине для каждой заявки вводится условный момент времени моделирования, когда она изменит своё состояние --- $T_{shift}$. В момент времени, когда $T_{shift} = T_{curr}$, заявка перемещается в очередной элемент модели, и  $T_{shift}$ обновляется им в зависимости от заданных параметров. Были введены следующие события, при которых заявка изменит своё состояние:
\begin{itemize}
	\item Генерация заявки --- в данном случае заявке присваивается условный момент времени моделирования $T_{shift}$, по наступлении которого она покинет входящий поток.
	\item Начало обслуживания заявки --- при поступлении заявки на прибор, он присваивает ей условный момент времени моделирования $T_{shift}$, в который она закончит свое обслуживание и покинет прибор.
	\item Поступление заявки на орбиту --- $T_{shift}$ для заявки определяется как момент, в который она покинет орбиту и попытается в очередной раз получить обслуживание.
\end{itemize}

На основе выделенных сущностей и описанного принципа работы программы была построена ее объектная модель, в последствии использованная для реализации.

Для обеспечения универсальности и возможности добавления новых разновидностей элементов модели был введен общий для них интерфейс Producer. Такое решение, в качестве побочного эффекта, также может позволять использовать различные элементы системы в несвойственных для них позициях в модели.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_producer.eps}
	\caption{Интерфейс Producer}
	\label{uml_producer}
\end{figure}

В абстрактном методе Produce должна находится логика работы элемента системы, именно этот метод будет вызываться в каждой итерации работы модели. Также в интерфейсе определены вспомогательные методы Tag, SlotAt и GetSlotNames, служащие для соединения элементов между собой и выбора типа элемента при инициализации системы. Метод Tag возвращает константную строку, определенную для каждой реализации интерфейса Producer. Метод SlotAt позволяет получить доступ к слоту соединения элемента.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_slot.eps}
	\caption{Класс Slot и его наследники}
	\label{uml_slot}
\end{figure}

Слоты используются в элементах системы для задания ограничения на возможные связи между другими элементами. К примеру, входящий поток может иметь только один выход для заявок, которые им генерируются, и не имеет входов, поскольку порождает заявки самостоятельно. В свою очередь, орбита должна иметь один вход для поступающих на нее заявок и один выход для отправления их обратно на прибор. Для разграничения логики работы слота на принимающий и отправляющий введено два наследника --- InSlot, способный только принимать заявки и OutSlot, предназначенный лишь для их отправления. Среда для переправки заявок между слотами обеспечивается за счет класса Router.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_router.eps}
	\caption{Класс Router}
	\label{uml_router}
\end{figure}
Маршрутизатор представляет собой очередь, работающую по принципу FIFO. Таким образом, он позволяет элементам системы взаимодействовать с заявками между итерациями, когда очередная заявка еще ожидает обработки, но текущая итерация подошла к концу.

Заявка представлена структурой Request, содержащей момент изменения ее состояния status\_change\_at ($T_{shift}$), тип, служащий для разделения способа происхождения заявки (была вызвана прибором, была порождена входящем потоком), и статус, отражающий этап ее обработки (обслужена, в процессе обслуживания, в пути, покинула систему).

Другим важным элементом предметной области является объект, генерирующий время задержки заявок в процессе их перемещения. Для этой цели служит интерфейс Delay.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_delay.eps}
	\caption{Интерфейс Delay и его реализации}
	\label{uml_delay}
\end{figure}
Каждый элемент системы массового обслуживания задает некоторую задержку, по прошествии которой обработка заявки будет закончена. Наличие интерфейса Delay позволяет проводить эксперименты, когда элементы системы могут задавать задержку для заявки разного рода. Так, к примеру, заявки на орбите могут иметь время задержки, распределенное равномерно. Имеется три реализации данного интерфейса: ExponentialDelay (экспоненциальная задержка), UniformDelay (равномерная задержка), GammaDelay (задержка, имеющая гамма--распределение).

Для инстанцирования реализаций вышеперечисленных интерфейсов, ввиду различных наборов параметров и требуемой возможности добавления новых реализаций элементов системы и видов задержки, используется шаблон проектирования \textquote{Абстрактная фабрика} \cite{lauder1998precise,fowler1997analysis}. В дополнение к шаблону был введен агрегирующий класс для фабрик, позволяющий регистрировать новые их реализации и, соответственно, расширять набор доступных элементов для моделирования.

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_delay_factory.eps}
	\caption{Использование шаблона проектирования \textquote{Абстрактная фабрика} для реализаций интерфейса Delay}
	\label{uml_delay_factory}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{uml_producer_factory.eps}
	\caption{Использование шаблона проектирования \textquote{Абстрактная фабрика} для реализаций интерфейса Producer}
	\label{uml_producer_factory}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[scale=1,width=\textwidth]{uml_po.eps}
	\caption{Объектная модель}
	\label{uml_po}
\end{figure}
На рисунке \ref{uml_po} представлена полная объектная модель предметной области программы. Упомянутые ранее интерфейсы имеют ряд реализаций для текущих целей исследовательской работы. Интерфейс Producer реализуется следующими классами:
\begin{itemize}
	\item MMPP --- служит для имитации работы Марковского модулированного пуассоновского процесса (MMPP). Для этого имеет поля, содержащие матрицу инфинитезимальных характеристик (q\_), вектор интенсивностей для каждого состояния (l\_), текущие состояние управляющей цепи (state\_), момент времени смены состояния управляющей цепи (shift\_time\_), а также метод метод для смены ее состояния shift.
	\item SimpleInput --- простейший входящий поток (Пуассоновский).
	\item RQTNode --- прибор, работающий в связке с орбитой и обратной связью.
	\item RQNode --- прибор, работающий в связке с орбитой.
	\item SimpleNode --- простейший вид обслуживающего прибора без очереди и орбиты.
	\item Orbit --- реализация орбиты, выполненная через наследованный от Producer интерфейс IOrbit, так как орбита нуждается в отдельном методе для помещения на нее заявок.
	\item StatCollector --- класс для сбора информации о выходящих процессах системы. Имеет методы и поля для расчета характеристик ее работы, таких как среднее число обслуженных вызванных и пришедших заявок, расчет двумерного, суммарного распределения, а также распределений выходящего процесса, обслуживающего входящие заявки и процесса, обслуживающие вызванные заявки. Также имеются методы, позволяющие рассчитать вариацию длин интервалов между моментами завершения обслуживания заявок для каждого из выходящих процессов. StatCollector является реализацией интерфейса Producer, поскольку такой подход позволяет естественным способом, а именно при помощи маршрутизатора, направлять заявки в объект для их обработки.
\end{itemize}
\subsubsection{Особенности реализации}
Программа полностью реализована на языке C++ стандарта 2017 года \cite{o2017mastering}. Решение использовать именно C++ было принято ввиду потребности обеспечения максимальной скорости работы имитационной модели. C++ в полной мере удовлетворяет данному критерию по ряду причин:
\begin{enumerate}
	\item Ручное управление памятью. С одной стороны, необходимость разработчику постоянно следить за выделяемой памятью и разрушением экземпляров объектов является недостатком, так как осложняет процесс разработки и способствует возникновению ошибок в управлении памятью, с другой --- дает возможность организовать подходящий под задачу процесс выделения памяти.
	\item Компиляция. Компилируемые языки всегда превосходят в производительности интерпретируемые, поскольку проверка типов, предупреждение возникших исключений и других ошибок происходят на этапе компиляции, а не в процессе работы программы.
	\item Статическая типизация. Заранее известные типы объектов ускоряют как компиляцию, так и работу программы ввиду отсутствия проверки типов.
	\item Объявление без инициализации. C++ позволяет объявить переменную, не инициализируя ее некоторым значением, что экономит время работы.
\end{enumerate}
Помимо этого C++ поддерживает принципы объектно--ориентированного программирования, в соответствии с которыми была спроектирована программа. Однако с некоторыми различиями, такими, как отсутствие интерфейсов в явном виде. Вместо них C++ поддерживает абстрактные классы с чистыми виртуальными функциями \cite{schmid2012c++}.

Для сборки программы использовался компилятор GCC, поскольку он поддерживается всеми платформами, а также имеет широкий спектр параметров для оптимизации кода на этапе компиляции \cite{branco2015impact}. Используемая для проведения экспериментов версия программы была собрана со следующими параметрами:
\lstset{language=bash,
	basicstyle=\linespread{0.8}\ttfamily,
	caption={Параметры компиляции программы}
}
\begin{lstlisting}
g++ -I ./include --std=c++17 -Ofast -fgcse-sm -fgcse-las 
\end{lstlisting}
Реализация имитационной модели рассчитана на работу в одном потоке центрального процессора, поэтому необходимости в сущностях, хранящих информацию о конкретном экземпляре запускаемой модели, нет. Так, глобальные переменные (очередь событий, текущее время моделирования, момент конца времени моделирования, интервал сбора статистики, список используемый маршрутизаторов, а также функция для соединения элементов маршрутизатором) объявлены в отдельном заголовочном файле
\lstset{language=C++,
	basicstyle=\linespread{0.8}\ttfamily,
	caption={Глобальные переменные и функции}
}
\begin{lstlisting}
	std::vector<double> EventQueue;
	
	void Init(){EventQueue.reserve(10);}

	double Time;
	double End;
	double Interval;
	
	std::unordered_map<std::string, Router *> Routers;
	void AnalRodeo(Producer *from, std::string from_slot,
		Producer *to, std::string to_slot) 
\end{lstlisting}
Задание параметров моделирования происходит из файла в формате JSON \cite{bourhis2017json}. Данное решение позволяет повторно запускать эксперименты с ранее подготовленными параметрами, структурировать наборы параметров при помощи операций с файловой системой (создание папок, именование), а также использовать вложенные структуры при описании работы того или иного элемента. Листинг задаваемых параметров в формате JSON представлен ниже
\lstset{
	basicstyle=\linespread{0.8}\ttfamily,
	caption={Параметры имитационной модели в формате JSON},
	label={lst:json}
	}
\begin{lstlisting} 
	{
		"input": {
			"type": "mmpp_input",
			"parameters": {
				"L": [0.079,0.539,0.102],
				"Q": [[-0.359,0.191,0.168],
				      [0.286,-0.41,0.123],
				      [0.302,0.075,-0.378]],
				"request_type": 0
			}
		},
		"node": {
			"type": "rqt_node",
			"parameters": {
				"mu_1": {
					"delay_type": "exponential",
					"intensity": 1.2
				},
				"mu_2": {
					"delay_type": "exponential",
					"intensity": 1.0
				}
			}
		},
		"called_input": {
			"type": "simple_input",
			"parameters": {
				"l": {
					"delay_type": "exponential",
					"intensity": 0
				},
				"request_type": 1,
				"intensity": 0.0
			}
		},
		"orbit": {
			"type": "orbit",
			"parameters": {
				"sigma": {
					"delay_type": "exponential",
					"intensity": 0.81
				}
			}
		},
		"stat": {
			"type": "stat_collector",
			"parameters": {"interval": 10}
		},
		"end": 10000000,
		"exports": ["chars","distr"],
		"export_prefix": "example_",
		"export_dir": "results",
	}
\end{lstlisting}
На листинге \ref{lst:json} показано, как, к примеру, задаются параметры входящего потока: 
объект input имеет тип (type), который в данном случае указан как MMPP (mmpp\_input), и требуемые для его работы параметры (parameters), включающие описание вектора интенсивностей L, матрицу инфинитезимальных характеристик Q и тип генерируемых заявок request\_type, имеющий значение 0, что соотносится с заявками входящего потока. Аналогичным образом задаются параметры для прибора (node), орбиты (orbit), источника вызываемых заявок (called\_input) и сборщика статистики о работе модели (stat). Ниже указано время моделирования в условных единицах (end), а также указания по экспортированию результатов. Массив exports может содержать два возможных значения --- \textquote{chars} и \textquote{distr}, которые указывают, что требуется экспортировать общие характеристики работы и распределения вероятностей соответственно.

Программа не имеет графического интерфейса для упрощения работы в связке с вспомогательными инструментами и возможности запуска на сервере. По окончании работы выбранные результаты будут экспортированы в файлы формата CSV.

\begin{table}[H] 
	\centering
	\caption{Вывод характеристик работы системы}
	\label{output_ex}
	\begin{tabular}{| c | c | c |}
		\hline
		characteristic & value & Комментарий  \\ 
		\hline
		elapsed & 3.08556 & \specialcell{Потребовавшееся время моделирования\\в секундах}\\
		\hline
		mean\_input & 1.73028 & \specialcell{Среднее число обслуженных заявок\\входящего потока}\\
		\hline
		mean\_called & 0 & \specialcell{Среднее число обслуженных\\вызванных заявок}  \\ 
		\hline
		variation\_input & 0.930848 & \specialcell{Вариация длин интервалов поступления\\заявок входящего потока}  \\ 
		\hline
		variation\_called & -nan & \specialcell{Вариация длин интервалов поступления\\вызываемых заявок}  \\ 
		\hline
		alpha & 0 & $\alpha$  \\ 
		\hline
		var & 1.33821 & \specialcell{Вариация длин интервалов поступления\\обслуженных заявок} \\ 
		\hline
		mu1 & 1.1 & $\mu_1$ \\ 
		\hline
		mu2 & 1 & $\mu_2$  \\ 
		\hline
		sigma & 0.01 & $\sigma$  \\ 
		\hline
	\end{tabular}
\end{table}
В таблице \ref{output_ex} представлен пример экспорта характеристик работы системы.
\subsection{Проведение экспериментов в большом объеме}
Разработанная имитационная модель является основным компонентом программного комплекса для исследования области применимости рассматриваемой модели. Ключевым преимуществом, по сравнению с ранее использованной имитационной моделью \cite{evm} с графическим интерфейсом, является полная автоматизация проведения экспериментов. В первую очередь, графический интерфейс отнимал у пользователя много времени, требуемого для запуска имитационной модели и сохранения результатов ее работы. Также, повторные запуски с одинаковыми параметрами требовали тех или иных манипуляций для их установки. Помимо этого, графическая оболочка отнимает ресурсы машины на собственный рэндеринг и в целом отрицательно сказывается на производительности. Интерфейс командной строки же позволяет запускать модель с нужными параметрами мгновенно, использовать инструменты операционной системы, такие как timeout \cite{taylor2004wicked}, а также интегрировать ее в другие программные инструменты и использовать в связке со скриптами.

Именно с помощью скриптов на языке Python была реализована возможность запускать эксперименты в больших масштабах. Для этой цели были написаны следующие модули:
\begin{itemize}
	\item rq\_system --- алгоритмы для вычисления всех полученных асимптотических формул, включая вероятности обслуживания указанного количества заявок за определенное время, вычисление коэффициента вариации длин интервалов между моментами поступления заявок входящего потока и другое.
	\item create\_params --- служит для генерации файлов в формате JSON, содержащих наборы параметров для запуска имитационной модели. Позволяет создавать как случайные наборы параметров, так и находящиеся в заданном интервале.
	\item run\_exps --- скрипт, работающий по принципу системы массового обслуживания с заданным количеством обслуживающих приборов, где в роли заявки выступает запуск экземпляра имитационной модели со сгенерированными ранее параметрами. Для обеспечения параллельного беспрерывного запуска использовалась встроенная библиотека Python multiprocessing \cite{hunt2019multiprocessing}. С помощью нее скрипт запускает заданное параметрами количество процессов-демонов, остающихся запущенными, даже если главный процесс завершит работу. Список файлов со сгенерированными параметрами разделяется на равные по длине подсписки. Каждый демон получает на вход один из подсписков и последовательно запускает экземпляры имитационной модели с полученными наборами параметров. Таким образом, процессам не требуется синхронизация, и они могут работать параллельно, не дожидаясь окончания работы модели у каждого из процессов. Для предотвращения ситуации, когда запущенная модель не заканчивает свою работу в течение продолжительного времени, используется утилита timeout, принудительно завершающая процесс по истечении заданного таймаута.
	\item to\_csv --- вспомогательный скрипт, агрегирующий файлы с результатами работы имитационной модели для последующего анализа.
\end{itemize}

При помощи разработанных инструментов было проведено около 286 тысяч запусков имитационной модели с различными параметрами. На выполнение всех запусков потребовалось 23 часа 17 минут. Эксперименты проводились на машине с установленным центральным процессором Intel Xeon Gold 5218R. Наличие 80-ти логических ядер позволило запускать соответствующие количество экспериментов параллельно за один раз. Потребление оперативной памяти при этом не превышало 240МБ. Описанные цифры явно демонстрируют эффективность выбранного подхода к анализу характеристик функционирования системы на основе имитационной модели. Провести вычисления подобного масштаба на стационарном компьютере было бы невозможно, что является большим достоинством реализованного программного комплекса.
\clearpage