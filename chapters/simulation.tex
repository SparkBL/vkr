\section{Имитационное моделирование}
В данной работе, для анализа полученных решений систем массового обслуживания с повторными вызовами и вызываемыми заявками используется имитационное моделирование. Построив имитационную модель системы, мы получаем возможность провести численное сравнение результатов ее работы с аналитическим решением для оценки его применимости на практике.

Имитационное моделирование систем массового обслуживания сводится к генерированию случайных времен с соответствующим распределением вероятности, по прошествии которого в системе наступит некоторое событие - приход заявки, окончание обслуживания и т.д., что называется дискретно-событийным подходом. Таким образом, в течение моделирования на протяжении некоторого заданного времени модель обрабатывает происходящие в системе события - они регистрируются, и на их основе подсчитываются численные характеристики, такие как распределение вероятности.

Реализованная имитационная модель, как программный продукт, разрабатывалась с возможностью расширения ее функционала для предоставления возможности тонко настраивать параметры моделирования и без препятствий извлекать полученные результаты в виде распределения вероятности для последующего анализа. В этих целях, программа реализована при помощи объектно ориентированного подхода, так как данный подход позволил выстроить логику работу программы на уровне абстракций, что и дает возможность легкого расширения функционала и реализации моделей других систем массового обслуживания.

\subsection {Объектная модель предметной области}
Для построения объектной модели предметной области программы рассматриваются следующие объекты систем массового обслуживания, используемые в данной работе:
\begin{itemize}
\item Заявка - объект, который поступает в систему, перемещается по ней и , в конечном итоге, покидает систему в течение моделирования.
\item Обслуживающий прибор - объект, принимающий на вход заявки и обслуживающий их. По окончании обслуживания заявки покидают прибор.
\item Орбита - скопление заявок, ожидающих повторного обращения на обслуживающий прибор.
\item Входящий поток - объект, генерирующий заявки, которые поступают на прибор.
	\end{itemize}
 Поскольку процесс работы модели заключается в перемещении заявок по системе, то в некоторый момент времени моделирования $T_{cur}$ местонахождение каждой заявки и ее характеристики могут меняться. В таком случае, необходимо отслуживать момент времени, в который заявка изменит свое состояние - $T_{shift}$. В момент времени, когда $T_{shift} = T_{curr}$,  происходит смена состояния заявки, и  $T_{shift}$ обновляется объектом системы массового обслуживания, в которой она на данный момент находится. Среди событий , при которых происходит обновление момента смены состояния заявки, выделим следующие:
\begin{itemize}
	\item Заявка покидает входящий поток - в данном случае в источнике генерируется новая заявка с моментом времени $T_{shift}$, при наступлении которого, она также покинет входящий поток.
	\item Заявка успешно поступила на прибор и начала обслуживаться - в этом случае обслуживающий прибор определяет для заявки момент времени $T_{shift}$, в который ее обслуживание закончится.
	\item При попытке поступить на прибор заявка застала его занятым обслуживанием другой заявки и отправилась на орбиту. По прибытии на орбиту, новый момент времени $T_{shift}$ заявки определяется как время, при наступлении которого заявка покинет орбиту.
\end{itemize}
Исходя из вышеописанного, центральными объектами в предметной области являются заявка и событие, наступающее в системе при смене состояния заявки. В предметной области они представлены классом Event, который связан ассоциацией с перечислением EventType, элементы которого соответствуют объектам системы обслуживания, в которых наступило  событие. Это позволяет собирать статистику о произошедших событиях в системе.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{event_uml.eps}
	\caption{Класс Event}
	\label{event_uml}
\end{figure}
Поле moment хранит момент времени $T_{shift}$ до изменения состояния объекта. Для того, чтобы определить, какое событие должно произойти в модели следующим, класс Event содержит статическую коллекцию собственных объектов - storage. При создании новых событий они также помещаются и в storage для того, чтобы в последствии извлекать следующее по времени событие c помощью метода PopClosestEvent.

Для реализации подхода, основанном на постоянном обновлении состоянии заявок, находящихся в системе, предметная область базируется на общем интерфейсе, который реализуют все конкретные элементы рассматриваемых систем массового обслуживания. Его цель заключается в формализации изменения состояния элемента системы с каждым промежутком времени, в течение которого наступило очередное событие. Поскольку, сам класс RQ-системы, как будет показано ниже, реализует данный интерфейс, то возможно использовать ее как входящий поток для другой системы.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{processable_uml.eps}
	\caption{Общий интерфейс Processable для всех элементов системы массового обслуживания}
	\label{processable_uml}
\end{figure}
Метод Process унифицирует все изменения в элементе системы массового обслуживания, которые должны произойти в нем при наступлении события. Реализация этого интерфейса не обязательно должна иметь только этот метод, так как для удобства организации логики работы элемента, удобно размещать некоторые алгоритмы в отдельным методах.

Также, не все элементы системы можно полностью описать данным интерфейсом - обслуживающий прибор и орбита, помимо общего метода Process, должны иметь точки входа для заявок. По этой причине для них определены соответствующие интерфейсы, наследуемые от Processable.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{inode_iorbit_uml.eps}
	\caption{Интерфейсы для обслуживающего прибора (INode) и орбиты (IOrbit), наследуемые от Processable}
	\label{inode_iorbit_uml}
\end{figure}
Метод IOrbit Accept служит для принятия заявок на орбиту, а метод INode Income - для принятия заявки на прибор для обслуживания. Отличие между данными методами заключается в том, что, если прибор занят обслуживанием другой заявки, то метод Income вернет заявку, которая пытается встать на прибор, в то время как орбита не имеет ограничения по количеству находящихся на ней заявок.

Для вычисления экспоненциальной задержки до наступления событий в модели, в предметную область был добавлен общий интерфейс для объектов, вычисляющих задержку, что позволяет менять способ вычисления задержки в процессе моделирования.
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{delayprovider_uml.eps}
	\caption{DelayProvider - интерфейс для вычисления задержки, который используют элементы системы массового обслуживания}
	\label{delayprovider_uml}
\end{figure}

Для обеспечения среды, которой будет происходит моделирование, а именно - вестись подсчет прошедшего времени, взаимодействие с реализацией интерфейса Processable и сбор статистики, введен глобальный объект Environment
\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{environment_uml.eps}
	\caption{Глобальный объект Environment}
	\label{environment_uml}
\end{figure}

Статический класс Environment содержит общую для модели информацию - время моделирования, время конца моделирования и методы, для управления этими параметрами. 
Члены класса Environment будут описаны в последующих разделах.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.79]{domain_uml.eps}
	\caption{Предметная область имитационной модели}
	\label{domain_uml}
\end{figure}
На рисунке \ref{domain_uml} представлена полная предметная область программы. Определенные ранее интерфейсы реализуют конкретные элементы системы, используемые при моделировании. Поскольку, в данной работе рассматривается RQ-система с простейшим и MMPP-потоками, существует две соответствующих реализации входящего потока, подробности функционирования которых будут рассмотрены в следующем разделе. Таким образом, существуют следующие реализации элементов систем массового обслуживания:
\begin{itemize}
	\item Orbit - реализация источника повторных вызовов, содержащая хранилище заявок (Event), что на диаграмме классов показано агрегацией. Поле delayIntensity хранит интенсивность обращений заявок с орбиты, то есть используется для вычисления экспоненциальной задержки соответствующим объектом delayProvider.
	\item CalledClaimsNode - реализация обслуживающего прибора, способная обслуживать два типа заявок - пришедшие извне и вызванные, для чего служат интенсивности serveIntensity и calledServeIntensity соответственно.
	\item SimpleInputProcess - реализация простейшего входящего потока, порождающего заявки. Ассоциация с Event показывает, что класс имеет поле с заявкой, которая готовится покинуть источник заявок по истечении задержки.
	\item MMPPInputProcess - реализация MMPP-потока. Поле shiftProbs хранит матрицу интенсивностей переходов между состояниями, а поле intensities - интенсивность поступления заявок для каждого состояния. Логика смены состояний находится в приватном методе Shift, где используются поле currentState - номер текущего состояния, а так же объект Event, в котором хранится момент сменты состояния входящего потока, что на диаграмме показано ассоциацией с множителем 2.
	\item RQSystem представляет агрегирующий класс, где при помощи описанных выше классов строится логика работы системы.
	\item Структура Statistic служит для сбора и подсчета различных характеристик системы в процессе моделирования - одномерного и двумерного распределения, математического ожидания и др. 
\end{itemize}
\clearpage
\subsection{Процесс моделирования}
В качестве среды для моделирования в реализованной программе выступает глобальный объект Environment, представленный на рисунке \ref{environment_uml}. В процессе моделирования у него вызывается метод NextMoment, который переносит систему в следующий момент моделирования, то есть, совершается одна итерация процесса моделирования. Перед началом моделирования вызывается метод Init, который подготавливает модель к началу работы. Метод isFinished служит для осведомления других участков программы, что моделирование окончено, то есть, что выставленное время моделирования (maxTime) равно текущему (time).

Для обеспечения гибкости действий, которые модель может совершать в процессе работы, метод NextMoment имеет частичную реализацую, в которой вызывается указатель на функцию или лямбда-выражение mainAction. Таким образом, поведение модели можно менять в процессе ее работы, что делает класс Environment универсальным для многих систем, использующих пошаговое моделирование.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{simulation_algo_uml.eps}
	\caption{Общий алгоритм процесса моделирования на основе класса Environment}
	\label{simulation_algo_uml}
\end{figure}

Для сбора статистики и построения распределения количества обслуженных заявок, в классе Environment предусмотрен механизм интервального сбора данных моделирования. Поле statInterval хранит интервал модельного времени, по прошествии которого должен производится вызов функции или лямбда выражения по указателю intervalAction, в котором задается логика сбора данных.

Как видно на рисунке \ref{domain_uml}, класс Environment работает в связке с классом Event, так как в нем содержится статистическая очередь событий storage, которые вскоре должны произойти в системе. Наглядно это показано на диаграмме последовательностей:
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{next_moment_algo_uml.eps}
	\caption{Диаграмма последовательностей метода NextMoment}
	\label{next_moment_algo_uml}
\end{figure}
После выполнения mainAction (1.1), из очереди событий извлекается первое предстоящее (1.2). Если такое нашлось, то модельное время перемещается на момент события (1.9). Если это время больше, чем время сбора статистики, то сначала выполняется сбор (1.8), и уже после этого модельное время смещается на момент события. Сбор статистики выполняется в цикле, так как время наступления события может больше интервала сбора статистики в несколько раз.

Функционирование же отдельных элементов системы описывается в методах интерфейса Processable и наследуемых от него INode и IOrbit.
Происходящее с обслуживающим прибором во время очередной итерации отражено на диаграммах последовательностей \ref{CalledClaimsNode_Process_uml} и \ref{CalledClaimsNode_Income_uml}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{CalledClaimsNode_Process.eps}
	\caption{Диаграмма последовательностей метода Process класса CalledClaimsNode}
	\label{CalledClaimsNode_Process_uml}
\end{figure}
Если прибор на данный момент не обслуживает заявку currentEvent (поле currentEvent на диаграмме \ref{domain_uml} обозначено ассоциацией), то возвращается NULL, говорящий о том, что на данной итерации прибор не закончил обслуживание заявки, так как он либо свободен, либо обслуживание еще продолжается. Иначе, производится проверка, совпадает ли текущее модельное время с моментом наступления события. При совпадении обслуженная заявка уходит с прибора (1.5, 1.6, 1.8).
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{CalledClaimsNode_Income.eps}
	\caption{Диаграмма последовательностей метода Income класса CalledClaimsNode}
	\label{CalledClaimsNode_Income_uml}
\end{figure}
В случае, если пришла заявка, и прибор свободен, пришедшая заявка становится текущей обслуживаемой на приборе (1.1), иначе она возвращается (1.13). В зависимости от типа пришедшей заявки для нее вычисляется время обслуживания - для заявок с входящего потока и орбиты используется serveIntensity (1.4, 1.6), а для  вызванных используется calledServeIntensity (1.8, 1.10).

Подобный алгоритм, заключающийся в проверке модельного времени с моментом наступления события, реализован и в других элементах системы.
В методе Accept класса Orbit также вычисляется задержка для пришедшей заявки. После чего она помещается в коллекцию claimStorage, отображенной на диаграмме предметной области (рисунок \ref{domain_uml}) в качестве ассоциации. В методе Process (рисунок \ref{Orbit_Process_uml}) производится обход данной коллекции со сравнением времени, когда заявка должна покинуть орбиту, и модельным временем. В случае, если нашлась готовая заявка, она извлекается (1.5) из коллекции и возвращается (1.6)
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.9]{Orbit_Process.eps}
 	\caption{Диаграмма последовательностей метода Process класса Orbit}
 	\label{Orbit_Process_uml}
 \end{figure}
Тот же подход используется для метода Process классов SimpleInputProcess и \\ MMPPInputProcess, однако подробного рассмотрения требует алгоритмы смены состояний управляющей цепи MMPP-потока, реализованного в методе Shift класса MMPPInputProcess.

Как было показано в главе \ref{mmpp_section}, время нахождения в одном из состояний и вероятность перехода в другое для MMPP-потока определяется матрицей инфинитезимальных характеристик $Q$
\begin{equation*}
	\boldsymbol{Q}=\begin{bmatrix}
		q_{11} &  \dots &  q_{1n}\\
		\vdots & \ddots &  \\
		q_{n1} &    	&	q_{nn}
	\end{bmatrix}
\end{equation*}
Интенсивностью, на основе которой вычисляется задержка потока в $i$-ом состоянии является диагональный элемент матрицы $-q_{i,i}$, а вероятностью перехода из $i$-ого состояния в $j$-ое является выражение $\frac{q_{i,j}}{-q_{i,i}}$.В таком случае, при наступлении события смены состояния выполняется следующий алгоритм
   \begin{figure}[H]
  	\centering
  	\includegraphics[scale=0.7]{shift_algo.eps}
  	\caption{Алгоритм смены состояния MMPP-потока}
  	\label{shift_algo_uml}
  \end{figure}
В начале работе вычисляется случайная величина chance, определяется переменная sum для суммирования вероятностей по строке матрицы $Q$ и счетчик цикла i. Цикл идет по строке текущего состояний currentState. В случае, если текущий элемент строки недиагональный, к sum прибавляется вероятность попадания в состояние i, после чего производится проверка, больше ли величина sum случайной величины chance. Графически это представляется таким образом, что точка chance принадлежит отрезку $[0,sum]$, а прибавленная к sum на текущей итерации вероятность попадания управляющей цепи в состояние i обеспечила принадлежность точки к отрезку, следовательно, прибор принимает состояние i.
\clearpage
\subsection{Интерфейс и работа программы}
Процесс работы с реализованной программой начинается с задания параметров системы в специальных полях. Для начала работы задаются следующие параметры:
\begin{itemize}
	\item Время моделирования
	\item Тип входящего потока
	\item Интенсивность входящего потока. Для MMPP-потока матрица инфинитезимальных характеристик и вектор интенсивностей задается в модельном окне
	\item Интенсивность вызова заявок прибором
	\item Интенсивность обслуживания входящих и вызванных заявок
	\item Интервал сбора статистики для построения распределения вероятности
\end{itemize}
   \begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{interface_params.eps}
	\caption{Алгоритм смены состояния MMPP-потока}
	\label{interface_params}
\end{figure}